## 一

watch监听同路由页面的跳转，

 `@click.stop="playing(info)"`

### 1-1

1. reslove

   ```js
   resolve(to: RouteLocationRaw): RouteLocation & {
     href: string
   }
   ```

#### 1-1-1 vue 自定义自定义路径别名

1. ` component: resolve => { require(['@views/index/Index.vue'], resolve) }`
2. `babel.config.js`中

### 1--1-2

1. 登录-----> 变 loginDialogVisible 的状态值，让弹窗弹出

### 1-1-3 插槽

```js
<i slot="prefix" class="iconfont icon-phone"></i>
```

1. 官网插槽定义 ： [插槽]([插槽 — Vue.js (vuejs.org)](https://cn.vuejs.org/v2/guide/components-slots.html#具名插槽))

### 1-1-4 this.$set()

1. https://www.jianshu.com/p/6f28f5abee08
2. https://cn.vuejs.org/v2/api/#Vue-set

### 1-1-5 vue 的 watch 用法

基本用法：
   当 firstName 值变化时，watch 监听到并且执行

```
<div>
      <p>FullName: {{fullName}}</p>
      <p>FirstName: <input type="text" v-model="firstName"></p>
</div>

new Vue({
  el: '#root',
  data: {
    firstName: 'Dawei',
    lastName: 'Lou',
    fullName: ''
  },
  watch: {
    firstName(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    }
  }
})
```

handler 方法和 immediate 属性：
   上面的例子是值变化时候，watch 才执行，我们想让值最初时候 watch 就执行就用到了 handler 和 immediate 属性

```
watch: {
firstName: {
handler(newName, oldName) {
this.fullName = newName + ' ' + this.lastName;
},
// 代表在 wacth 里声明了 firstName 这个方法之后立即先去执行 handler 方法，如果设置了 false，那么效果和上边例子一样
immediate: true
}
}
```

deep 属性（深度监听，常用语对象下面属性的改变）：

```html
<div>
  <p>obj.a: {{obj.a}}</p>
  <p>obj.a: <input type="text" v-model="obj.a" /></p>
</div>

new Vue({ el: '#root', data: { obj: { a: 123 } }, watch: { obj: {
handler(newName, oldName) { console.log('obj.a changed'); }, immediate: true } }
})
```

我们在在输入框中输入数据视图改变 obj.a 的值时，我们发现是无效的。受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

默认情况下 handler 只监听 obj 这个属性它的引用的变化，我们只有给 obj 赋值的时候它才会监听到，比如我们在 mounted 事件钩子函数中对 obj 进行重新赋值：

```
mounted: {
this.obj = {
a: '456'
}
}
```

那么我们需要监听 obj 里的属性 a 的值呢？这时候 deep 属性就派上用场了:

```js
watch: {
  obj: {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    deep: true
  }
}
```

这样的方法对性能影响很大，修改 obj 里面任何一个属性都会触发这个监听器里的 handler。我们可以做如下处理：

```js
watch: {
  'obj.a': {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    // deep: true
  }
}
```

watch 的注销这里就不在多说了，实际开发中，watch 会随着组件一并销毁。





### 1-1-6 vuex的mutation和action的区别和使用

mutation
更改 vuex 的 store 中的状态的唯一方法是提交 mutation。vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：

this.$store.commit(“mutation函数名”，发送到mutation中的数据)

Action
actions函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。

this.$store.dispatch(‘action中的函数名’，发送到action中的数据)

在action中提交mutation ：
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {    //官方给出的指定对象, 此处context可以理解为store对象
      context.commit('increment');
    }
  }
})

actions的不同写法
// 第一种写法简写形式
　　const actions = {
　　　　action的函数名({commit}) { 
　　　　　　commit(“mutation函数名”, value);   //调用mutation中的函数
　　　　　　//此处value可以是对象,可以是固定值等
　　　　}
　　}
　　// 第二种形式
　　const actions = {
　　　　action中的函数名(context) {
　　　　　　//context 官方给出的指定对象, 此处context可以理解为store对象
　　　　　　context.commit(“mutation函数名”, value);     //调用mutation中的函数
　　　　}
　　}
1、流程顺序

“相应视图—>修改State”拆分成两部分，视图触发Action，Action再触发Mutation。

2、角色定位

基于流程顺序，二者扮演不同的角色。

Mutation：专注于修改State，理论上是修改State的唯一途径。

Action：业务代码、异步请求。

3、限制

角色不同，二者有不同的限制。

Mutation：必须同步执行。

Action：可以异步，但不能直接操作State。而且可以通过 action 来提交 mutations
————————————————
版权声明：本文为CSDN博主「青梅主码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qmzma/article/details/119327300





### 1-1-7 

1. JavaScript JSON.stringify()

   

   ------

   JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。

### 1-1-8 {commit}

# [Vuex- Action的 { commit }的写法](https://segmentfault.com/a/1190000022018995)

[![img](https://avatar-static.segmentfault.com/106/633/106633531-5e50ca34853ba_huge128)**九零七**](https://segmentfault.com/u/jiulingqi)发布于 2020-03-15

![img](https://sponsor.segmentfault.com/lg.php?bannerid=0&campaignid=0&zoneid=25&loc=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000022018995&referer=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3D-iYZLs90_PyLOgUB5_-vv8V4pT_0EnKimcMkOY-ROz2__6kFHyYU59akrGfoczO8OgWu2HYOLaguJ-h45JLlyK%26wd%3D%26eqid%3Dd65f3ad10007eed600000002622fee45&cb=a72159d4bc)

**vuex教程中，有这样一句话和这样一段代码：**

> 实践中，我们会经常用到 ES2015 的[参数解构](https://link.segmentfault.com/?enc=MbMZUGyfNwjMLfigq0n7qw%3D%3D.8%2F3DMFER4la7zZTLnBgbdJjAacl1eIMGJiURfrenUOfqoGJanoro4MXpCuryTzI6u9mEpK03UjSePr1WJaS0wA%3D%3D)来简化代码（特别是我们需要调用`commit`很多次的时候）：

```scss
actions: {
  increment ({ commit }) {
    commit('increment')
  }
}
```

**其中，{commit} 写法是解构后得到的，下面就简短解释一下简化的过程：**

------

**知识点：**

> Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象
> 因此这个context参数可以理解为store
> 即这个context参数可以使用commit提交mutation

**所以，context也同样包含以下属性**

```autohotkey
{
  state,      // 等同于 `store.state`，若在模块中则为局部状态
  rootState,  // 等同于 `store.state`，只存在于模块中
  commit,     // 等同于 `store.commit`
  dispatch,   // 等同于 `store.dispatch`
  getters,    // 等同于 `store.getters`
  rootGetters // 等同于 `store.getters`，只存在于模块中
}
```

**原写法：**

```scss
actions: {
  increment (context) {
    context.commit('increment')
  }
}
```

**相当于：**

```roboconf
actions:{
  increment ({ commit: context.commit }) {
    context.commit('increment');
  }
}
```

**相当于：**

```scss
actions: {
  increment ({ commit }) {
    commit('increment')
  }
} 
```

------

借鉴ES2015中对象的解构

```arcade
var { foo, bar } = { foo: "lorem", bar: "ipsum" };
console.log(foo);// "lorem"
console.log(bar);// "ipsum"
```





### 1-1-9 

vuex在action中提交commit异步事件问题

专业前端小白

于 2020-05-20 11:41:49 发布

2144
 收藏 1
分类专栏： vue vuex 文章标签： vue vuex commit
版权

vue
同时被 2 个专栏收录
10 篇文章0 订阅
订阅专栏

vuex
1 篇文章0 订阅
订阅专栏
在开发过程中遇到一个问题，就是在action中提交的commit执行是异步事件。

先看代码：

// action.js
sign_in({ commit }, user) {
    // 触发登录状态
    commit({
      type: 'sigin_in',
      payload : {
          user  
      }
    });
    console.log("++++++");
},

 

// mutations.js
async sigin_in(state, { payload }) {
    await axios.post("api/login",payload.user);

    console.log("------");
}


//输出
++++++
------


如上所示，如果在mutations中使用async/await的话就会使得commit变成异步函数。

解决办法：

一、将axios异步进程放在action中执行。

二、不要使用async/await，在axios的then中进行业务逻辑，代码如下：

sigin_in(state, { payload }) {
    axios.post("api/login",payload.user).then(res => {
        // do somthing...
        
    });
}
官方的说法是不建议将异步事件放在mutations中执行，但如果情况特殊，只能在mutations中进行异步的话只有使用上面的方法了。
————————————————
版权声明：本文为CSDN博主「专业前端小白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41756580/article/details/106231962



### 1-1-10 

1. ![image-20220315145128415](https://gitee.com/hannah_bingo/yyy/raw/master/image-20220315145128415.png)
   - 如何找到对应引入文件的位置





### 1-1-11 .

1. .stop修饰符是用来阻止冒泡事件的发生的。

   用法如下：

   ```
   <a v-on:click.stop="doThis"></a>
   ```

2. 。self

   capture和self主要是函数执行顺序的问题

   .capture先执行父级的函数，再执行子级的触发函数(一般用法)，
   即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。

   <div v-on:click.capture='alert("1")' style="width: 100%;height: 45px;background-color: black;">
   			<div v-on:click="alert('2')" style='width: 80%;margin-left: 10%;background-color: white;'>
   				123
   			</div>
   		</div>
   1
   2
   3
   4
   5
   6
   此时点击子级的div时，会先执行alert(‘1’),再执行alert(‘2’)
   self是只执行子级本身的函数

   <div v-on:click.self='alert("1")' style="width: 100%;height: 45px;background-color: black;">
   			<div v-on:click="alert('2')" style='width: 80%;margin-left: 10%;background-color: white;'>
   				123
   			</div>
   		</div>
   1
   2
   3
   4
   5
   此时点击子级的div会执行alert(‘2’)，不会执行alert(‘1’)
   ————————————————
   版权声明：本文为CSDN博主「翼晗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
   原文链接：https://blog.csdn.net/qq_34164814/article/details/80468949
